# -*- coding: utf-8 -*-
"""ConsolidationCopy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IShJ8L6riobJwtm1ttfS79bhCPkKZWHM
"""

import pandas as pd
import itertools

def load_data(path, sheet_name=None):
    """
    Load Excel or CSV file, read columns rlength, rwidth, rheight, compute volume.
    """
    try:
        # Check file extension
        if path.endswith('.csv'):
            df = pd.read_csv(path)
        elif path.endswith(('.xlsx', '.xls')):
            # If no sheet_name provided, use the first sheet
            if sheet_name is None:
                df = pd.read_excel(path)
            else:
                df = pd.read_excel(path, sheet_name=sheet_name)
        else:
            raise ValueError("Unsupported file format. Use .xlsx, .xls, or .csv")
        
        # Check if required columns exist
        required_columns = ["rlength", "rwidth", "rheight"]
        missing_columns = [col for col in required_columns if col not in df.columns]
        
        if missing_columns:
            raise ValueError(f"Missing required columns: {missing_columns}")
        
        # Clean and process data
        df = df[required_columns].dropna()
        df = df.astype({"rlength": float, "rwidth": float, "rheight": float})
        df["volume"] = df["rlength"] * df["rwidth"] * df["rheight"]
        
        return df

def exclude_largest(df):
    """
    Exclude the single row with maximum rlength.
    Returns that row and the remaining DataFrame.
    """
    idx = df["rlength"].idxmax()
    largest = df.loc[[idx]].copy()
    candidates = df.drop(idx).reset_index(drop=True)
    return largest, candidates

def fits_and_fill_rate(box_dims, items, allow_rotation=False):
    """
    Check if items fit into box_dims and compute minimum fill rate.
    """
    Lb, Wb, Hb = box_dims
    box_vol = Lb * Wb * Hb
    fill_rates = []
    for li, wi, hi in items:
        fits = False
        if allow_rotation:
            for perm in itertools.permutations((li, wi, hi)):
                if perm[0] <= Lb and perm[1] <= Wb and perm[2] <= Hb:
                    fits = True
                    break
        else:
            fits = (li <= Lb and wi <= Wb and hi <= Hb)
        if not fits:
            return False, 0.0
        fill_rates.append((li * wi * hi) / box_vol)
    return True, min(fill_rates)

def greedy_consolidation(df, target_k, fill_threshold=0.7, allow_rot=False):
    """
    Merge until total boxes (including largest) equals target_k.
    """
    largest, candidates = exclude_largest(df)
    clusters = [
        {"items": [i], "dims": (row.rlength, row.rwidth, row.rheight)}
        for i, row in candidates.iterrows()
    ]

    def volume(d): return d[0] * d[1] * d[2]

    while len(clusters) + 1 > target_k and len(clusters) > 1:
        best = None
        best_inc = float('inf')
        for i in range(len(clusters)):
            for j in range(i+1, len(clusters)):
                d1, d2 = clusters[i]['dims'], clusters[j]['dims']
                new_dims = tuple(max(a,b) for a,b in zip(d1, d2))
                items = [
                    candidates.loc[idx, ['rlength','rwidth','rheight']].tolist()
                    for idx in clusters[i]['items'] + clusters[j]['items']
                ]
                ok, fr = fits_and_fill_rate(new_dims, items, allow_rot)
                if ok and fr >= fill_threshold:
                    inc = volume(new_dims) - max(volume(d1), volume(d2))
                    if inc < best_inc:
                        best = (i, j, new_dims)
                        best_inc = inc
        if not best:
            break
        i,j,new_dims = best
        clusters[i]['dims'] = new_dims
        clusters[i]['items'] += clusters[j]['items']
        clusters.pop(j)

    final = []
    final.append({
        'box_id': 1,
        'rlength': float(largest.rlength.values[0]),
        'rwidth': float(largest.rwidth.values[0]),
        'rheight': float(largest.rheight.values[0])
    })
    for idx, c in enumerate(clusters, start=2):
        l,w,h = c['dims']
        final.append({'box_id': idx, 'rlength': l, 'rwidth': w, 'rheight': h})
    return final

def save_to_csv(boxes, output_path):
    df = pd.DataFrame(boxes)
    df.to_csv(output_path, index=False)

#Returns Average Volume
def average_box_metric(boxes):
    total = 0.0
    count = 0
    for b in boxes:
        for k in ('Volume'):
            total += b[k]
            count += 1
    return total / count if count else 0.0
